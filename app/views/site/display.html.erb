<canvas id="canvas" width="900" height="500"></canvas>

<script>

  $(document).on('ready', function(){
    var width = $(window).width();
    var height = $(window).height();


    // initialize canvas

    var canvas = document.getElementById('canvas');
    canvas.width = width;
    canvas.height = height;

    var c = canvas.getContext("2d");

    var circleHeight = height / 6;
    var lightWidth = width / 2 - 350;
    var temperatureWidth = width / 2;
    var soundWidth = width / 2 + 350;


    // draw sky and mountains

    var skyColor = 'rgb(162, 198, 245)';
    c.fillStyle = skyColor;
    c.fillRect(0, 0, width, height);

    // mountainrange code adapted from http://cs.lmu.edu/~ray/notes/canvas/

    var x;
    var y;
    var ruggedness;
    var smoothing;
    var range = 0.9;

    scale = function (x) {
      if ( range === 0.9 ) {
        range = 0.4;
      } else if ( range === 0.5 ) {
        range = 0.9;
      } else {
        range = 0.5;
      }
      return -( x / 2.0 ) + x * range; //Math.random();
    };

    // Draws a fractal line by recursive decomposition, using the global ruggedness
    // value.  The line is drawn from (x,y) to (tox,toy).  After the line is drawn,
    // (x,y) is updated to the value of (tox, toy).
    fractalLine = function (tox, toy) {
        if (x + 1 > tox) {
            c.lineTo(x = tox, y = toy);
        } else {
            var midx = (x + tox) / 2,
                midy = (y + toy) / 2 + scale(ruggedness * (tox - x) * smoothing);
            fractalLine(midx, midy);
            fractalLine(tox, toy);
        }
    };

    drawMountain = function (ruggedValue, mountainColor, edgeHeight, smoothValue) {
        ruggedness = ruggedValue;
        smoothing = smoothValue;
        c.beginPath();
        c.moveTo(0, height);
        c.lineTo(x = 0, y = edgeHeight);
        fractalLine(width, edgeHeight);
        c.lineTo(width, height);
        c.closePath();
        c.fillStyle = mountainColor;
        c.fill();
        c.fillStyle = "rgb(0, 0, 0)";
    };

    var mountainColors = ['lightgrey', 'darkgrey', 'grey'];
    var ruggedValues = [0.2, 0.4, 0.6];
    var edgeHeights = [height / 2.6, height / 2.1, height / 1.6];
    var smoothings = [1.3, 0.7, 0.4];

    for (var i = 0; i < 3; i++) {
      drawMountain(ruggedValues[i], mountainColors[i], edgeHeights[i], smoothings[i]);
    };


    // set AJAX calls for sensor inputs

    var counter = 5000;
    var ajaxCall = function() {
      // counter --;
      // if ( counter === 0 ) {
      //   clearInterval(ajaxCallInterval);
      // } else {
      //   console.log("Counter: " + counter);
      // }
      $.ajax({
        type: 'GET',
        url: '/input.json',
        async: true, // take out
        success: function(data){
          console.log("Light: " + data.light);
          console.log("Temperature: " + data.temperature);
          console.log("Sound: " + data.sound);
          console.log("Volume: " + data.volume);
          updateLight(data.light);
          updateTemperature(data.temperature);
          updateSound(data.sound);
          updateVolume(data.volume);
        },
        error: function(XMLHttpRequest, textStatus, errorThrown) { 
          console.log("Status: " + textStatus);
          console.log("Error: " + errorThrown); 
        }
      })
    };

    var ajaxCallInterval = setInterval(ajaxCall, 100);


    // initialize input history circular buffers

    createCircularBuffer("lightHistory", 30);
    createCircularBuffer("tempHistory", 30);
    createCircularBuffer("volumeHistory", 30);
    createCircularBuffer("soundHistory", 30);


    // canvas update functions

    function updateLight(light) {
      updateBuffer(lightHistory, light);
      var red = map(light, 200, 1000, 0, 48);
      var green = map(light, 200, 1000, 8, 133);
      var blue = map(light, 200, 1000, 97, 227);

      c.fillStyle = skyColor;
      c.fillRect(lightWidth - 90, circleHeight - 90, 180, 180);

      c.fillStyle = 'rgb(' + red + ',' + green + ',' + blue +')';
      c.beginPath();
      c.arc(lightWidth, circleHeight, 90, 0, Math.PI * 2, true);
      c.fill();

      c.fillStyle = 'red';
      var widthOffset = 0;
      _.each(getBufferHistory(lightHistory), function(value){
        var newValue = map(value, 200, 1000, 0, 90);
        c.fillRect(lightWidth - 90 + widthOffset, circleHeight - newValue + 90, 5, newValue);
        widthOffset = widthOffset + 6;
      })
    };

    function updateTemperature(temp) {
      updateBuffer(tempHistory, temp);

      c.fillStyle = skyColor;
      c.fillRect(temperatureWidth - 90, circleHeight - 90, 180, 180);

      var red = map(temp, 120, 190, 0, 48);
      var green = map(temp, 120, 190, 0, 133);
      var blue = map(temp, 120, 190, 0, 227);
      c.fillStyle = 'rgb(' + red + ',' + green + ',' + blue +')';
      c.beginPath();
      c.arc(temperatureWidth, circleHeight, 90, 0, Math.PI * 2, true);
      c.fill();

      c.fillStyle = 'red';
      var widthOffset = 0;
      _.each(getBufferHistory(tempHistory), function(value){
        var newValue = map(value, 120, 190, 0, 90);
        c.fillRect(temperatureWidth - 90 + widthOffset, circleHeight - newValue + 90, 5, newValue);
        widthOffset = widthOffset + 6;
      })
    };

    function updateVolume(volume) {
      if ( volume < 400 ) {
        volume = 800 - volume;
      }

      updateBuffer(volumeHistory, volume);
      var red = map(volume, 400, 1200, 0, 48);
      var green = map(volume, 400, 1200, 0, 133);
      var blue = map(volume, 400, 1200, 0, 227);
      c.fillStyle = 'rgb(' + red + ',' + green + ',' + blue +')';
      c.beginPath();
      c.arc(soundWidth, circleHeight, 90, 0, Math.PI * 2, true);
      c.fill();

      c.fillStyle = 'red';
      var widthOffset = 0;
      _.each(getBufferHistory(volumeHistory), function(value){
        var newValue = map(value, 400, 1200, 0, 90);
        c.fillRect(soundWidth - 90 + widthOffset, circleHeight - newValue + 90, 5, newValue);
        widthOffset = widthOffset + 6;
      })
    };

    function updateSound(sound) {
      c.fillStyle = skyColor;
      c.fillRect(soundWidth - 90, circleHeight - 90, 180, 180);

      updateBuffer(soundHistory, sound);
      if (sound === true) {
        c.strokeStyle = 'red';
      } else {
        c.strokeStyle = 'lightgrey';
      }

      c.lineWidth = 9;
      c.beginPath();
      c.arc(soundWidth, circleHeight, 90, 0, Math.PI * 2, true);
      c.stroke();
    };


    // other function implementations

    function map(value, lower1, upper1, lower2, upper2) {
      var result;
      if ( lower1 == upper1 || lower2 == upper2 ) {
        return null;
      }
      else {
        var percentage = ( value - lower1 ) / ( upper1 - lower1 );
        var newValue = percentage * ( upper2 - lower2 ) + lower2;
        return Math.round(newValue);
      }
    };

    function createCircularBuffer(bufferName, bufferLength){ // string, number
      window[bufferName] = [];
      for ( var i = 0; i < bufferLength; i++ ) {
        window[bufferName].push(null);
      }
      window[bufferName].pointer = 0;
    }

    function updateBuffer(buffer, value){ // variable, number
      buffer[buffer.pointer] = value;
      if ( buffer.pointer < buffer.length - 1 ) {
        buffer.pointer ++;
      } else {
        buffer.pointer = 0;
      }
    }

    function getBufferHistory(buffer) { // variable
      var history = [];
      for ( var i = 0; i < buffer.length; i++ ) {
        if ( buffer[buffer.pointer] ) history.push(buffer[buffer.pointer]);
        if ( buffer.pointer < buffer.length - 1 ) {
          buffer.pointer ++;
        } else {
          buffer.pointer = 0;
        }
      }
      return history;
    }

  });

</script>